%{
open MiniJson.JsonModule

let fail (parseState : Microsoft.FSharp.Text.Parsing.IParseState) (description : string) =
  let b,e = parseState.ResultRange
  failwithf "(%d,%d) - %A" b.Line b.Column description
%}

%start start

%token <float>  NUMBER_V
%token <string> STRING_V LEX_ERROR
%token TRUE_V FALSE_V NULL_V V_SEP KV_SEP O_BEGIN O_END A_BEGIN A_END EOF

%type < Json > start

%%

start: Full { $1 }

Recover:
  | LEX_ERROR             { fail parseState $1        }
  | error                 {                           }

Full:
  | Value EOF             { $1                        }
  | Recover               { fail parseState "EOF"     }

Value:
  | TRUE_V                { JsonBoolean true          }
  | FALSE_V               { JsonBoolean false         }
  | NULL_V                { JsonNull                  }
  | NUMBER_V              { JsonNumber ($1)           }
  | STRING_V              { JsonString ($1)           }
  | Object                { $1                        }
  | Array                 { $1                        }
  | Recover               { fail parseState "VALUE"   }

Object:
  | O_BEGIN O_END         { JsonObject []             }
  | O_BEGIN Members O_END { JsonObject $2             }
  | Recover               { fail parseState "OBJECT"  }

Members:
  | Member V_SEP Members  { $1::$3                    }
  | Member                { [$1]                      }
  | Recover               { fail parseState "MEMBERS" }

Member:
  | STRING_V KV_SEP Value { $1,$3                     }
  | Recover               { fail parseState "MEMBER"  }

Array:
  | A_BEGIN A_END         { JsonArray []              }
  | A_BEGIN Values A_END  { JsonArray $2              }
  | Recover               { fail parseState "ARRAY"   }

Values:
  | Value V_SEP Values    { $1::$3                    }
  | Value                 { [$1]                      }
  | Recover               { fail parseState "VALUES"  }
